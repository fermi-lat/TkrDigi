// $Header: /nfs/slac/g/glast/ground/cvs/TkrDigi/src/SiStripList.h,v 1.4 2002/09/08 15:36:06 lsrea Exp $

#ifndef SiStripList_H
#define SiStripList_H

#include <vector>
#include <algorithm>
#include "CLHEP/Geometry/Vector3D.h"
#include "GlastSvc/GlastDetSvc/IGlastDetSvc.h"
#include "Event/MonteCarlo/McPositionHit.h"

class SiStripList {
public:
    SiStripList(){}
    
    ~SiStripList();
    
    
    void score(const HepPoint3D& o, const HepPoint3D& p, Event::McPositionHit* pHit);
    
    void clear();
    
    /// add noise and remove hits below threshold
    /**
    *  @param noise_sigma noise rms in MeV
    *  @param occupancy  fraction of time a cell is occupied
    *  @param theshold   minimium energy deposit (MeV) that results in a latch
    */
    
    void addNoise(double noise_sigma, double occupancy, double threshold);

    typedef std::vector<Event::McPositionHit*> hitList;

    /// Strip data declaration
    class Strip 
    {
    public:
        
        // constructor
        Strip (int index = -1, double energy = 0, bool noise=false,
            Event::McPositionHit* pHit = 0)
            :m_index(index), m_energy(energy), m_noise(noise)

        {addHit(pHit);}
        
        // access, 
        void addEnergy (float e)    {  m_energy += e;   }   // add energy
        void energy (float e)       {  m_energy = e;    }   // set energy
        float energy () const       {  return m_energy; }   // get energy
        unsigned int index() const  {  return m_index;  }   // get index
        bool noise() const          {  return m_noise;  }   // get noise status
        void addHit(Event::McPositionHit* hit) 
        {
            hitList::iterator it = std::find(m_hits.begin(), m_hits.end(), hit);
            if (it==m_hits.end()) {
                m_hits.push_back(hit);
            }
            
        }
        hitList::const_iterator  begin () const { return m_hits.begin(); } 
        hitList::const_iterator  end () const { return m_hits.end(); }
        const hitList& getHits() const { return m_hits;}
        int size () const { return m_hits.size(); }


        
        // static parameters
        // undefined strip (non-existent)
        static int undef_strip () { return 65535; } 
        
    private:
        /// strip number, -1 if invalid
        int     m_index; 
        /// charge deposited
        float   m_energy;
        /// true if generated by noise
        bool    m_noise;  
        /// list of mc hits contributing to this strip
        hitList m_hits;   
    };

    
    
    /// for access to the service
    static StatusCode initialize(IGlastDetSvc* detsvc);
    
    typedef std::vector < Strip > StripList;            // list of hit strips
    typedef StripList::const_iterator const_iterator;   // iterator
    typedef StripList::iterator iterator;   
    
    // wrap std::vector members
    // access to the list of strips
    const_iterator  begin () const { return m_strips.begin(); } 
    const_iterator  end () const { return m_strips.end(); }
    int size () const { return m_strips.size(); }
    bool empty() const { return size()==0; }
    
    
    static IGlastDetSvc* s_detsvc;
    
    // compute local coordinate from strip id
    static double calculateBin (int x);   
    
    static int stripId(double x);
    void addStrip(int ix, float dE, Event::McPositionHit* pHit);
    
    
    // access
    iterator    begin () { return m_strips.begin(); }
    iterator    end () { return m_strips.end(); }
    iterator    insert (iterator it, const Strip& x) {
        return m_strips.insert(it, x); }
    iterator    erase (iterator it) { return m_strips.erase(it); }
    void        push_back (const Strip& x) { m_strips.push_back(x); }
    
    StripList   m_strips;
    
    /// number of silicon dies across a single layer
    static int n_si_dies ();
    
    /// number of silicon strips across a single die
    static int strips_per_die ();
    
    /// width of a single si die
    static double die_width ();
    
    /// number of silicon strips in a single layer
    static unsigned int n_si_strips ();
    
    /// number of front-end chips on a single si die
    static unsigned int n_fe_chips ();
    
    /// silicon strip pitch (computed from n_fe_chips & active are of the die)
    static double si_strip_pitch ();
        
    /// gap between the edge of the silicon die and the tray closeout
    static double electronics_gap ();
    
    /// gap between Silicon dies
    static double ssd_gap ();
    
    /// gap between ladders
    static double ladder_gap ();
    
    /// width of dead area, aka guarg_ring
    static double guard_ring ();

    /// width of entire panel (ladders + gaps)
    static double panel_width(); 
    
private:
        
    static double s_dice_width;
    static double s_ssd_gap;
    static double s_ladder_gap;
    static double s_guard_ring;
    static double s_panel_width;
    static int    s_stripPerWafer;
    static int    s_n_si_dies;       
};

#endif
